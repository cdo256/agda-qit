open import QIT.Prelude
open import QIT.Relation.Binary
open import QIT.Container.Base

-- Define plump ordinals Z of a given shape. They are used as size
-- bounds on trees for constructing diagrams, and then colimits.
-- This definition was copied from Fiore et al. 2022, and their earlier work (Pitts et al. 2021).
-- Start with an shape and position. This represents the 'shape' of
-- the underlying W-type being constructed.
module QIT.Relation.Plump {ℓS ℓP} (S : Set ℓS) (P : S → Set ℓP) where

private
  T = W S P

-- We extend S to Sᶻ in order to build an ordinal-like size type Z that
-- has:
-- - a bottom element (global minimum)
-- - a binary join operation (to combine bounds)
-- - an embedding of the original shapes
--
-- These extra shapes are proof-engineering conveniences used later to:
-- - ensure there is a canonical minimal stage (⊥ᶻ),
-- - combine two bounds to a larger bound (α ∨ᶻ β),
-- - lift base trees into Z (ιᶻ).
--
-- The join is not required to be a least upper bound; we only need it
-- to be an upper bound with α ≤ α ∨ᶻ β and β ≤ α ∨ᶻ β.
data Sᶻ : Set ℓS where
  ⊥ˢ : Sᶻ
  ∨ˢ : Sᶻ
  ιˢ : S → Sᶻ

-- Positions for the extended shapes:
-- - ⊥ˢ has no positions (so sup(⊥ˢ,_) is a leaf).
-- - ∨ˢ has two positions (so sup(∨ˢ,_) has two children).
-- - ιˢ s uses the original positions P s.
--
-- Lift is used only to keep the universe level uniform.
Pᶻ : Sᶻ → Set ℓP
Pᶻ ⊥ˢ = Lift _ ⊥
Pᶻ ∨ˢ = Lift _ (⊤ ⊎ ⊤)
Pᶻ (ιˢ s) = P s

-- Plump ordinals Z are W-trees over the extended signature (Sᶻ, Pᶻ).
-- Elements of Z are used as size bounds.
Z : Set (ℓS ⊔ ℓP)
Z = W Sᶻ Pᶻ

-- Canonical bottom element: a leaf with shape ⊥ˢ.
⊥ᶻ : Z
⊥ᶻ = sup (⊥ˢ , λ ())

-- A simple "successor-like" operation obtained via the binary join
-- node, with both children equal to α. This is not the usual ordinal
-- successor; it is just a convenient way to produce a strictly larger
-- bound (proved later as α < sucᶻ α).
sucᶻ : Z → Z
sucᶻ α = sup (∨ˢ , λ _ → α)

-- Define branching/join.
-- α ∨ᶻ β is a 2-branch node whose left child is α and right child is β.
-- Note: α and β are strictly less than α ∨ᶻ β, but we do not claim it
-- is the least upper bound. (We only need a combinator producing some
-- upper bound.)
_∨ᶻ_ : Z → Z → Z
_∨ᶻ_ α β = sup (∨ˢ , f)
  where
  f : Pᶻ ∨ˢ → W Sᶻ Pᶻ
  f (lift (inj₁ tt)) = α
  f (lift (inj₂ tt)) = β

-- Canonical inclusion from base trees T into plump ordinals Z:
-- map each original node shape s to the embedded shape ιˢ s.
-- This lets us compare/bound base terms t : T by ordinals α : Z.
ιᶻ : T → Z
ιᶻ (sup (s , f)) = sup (ιˢ s , λ α → ιᶻ (f α))

-- Define a well-founded order (≤, <) on Z.
--
-- This is not the usual extensional order on W-trees; instead it is
-- designed to support "plumpness" properties. The defining clauses are:
--
-- (1) sup≤ : sup(s,f) ≤ α if every child f β is strictly below α.
-- (2) <sup : α < sup(s,f) if α ≤ some child f β.
--
-- The intent is that sup(s,f) is "just above" its children, and ≤ is
-- generated by one-step closure under taking suprema.
mutual
  infix 4 _≤_ _<_

  -- sup≤: a supremum is ≤ α provided all its children are < α.
  data _≤_ : Z → Z → Prop (ℓS ⊔ ℓP) where
    sup≤ : {s : Sᶻ} {f : Pᶻ s → Z}
         → {α : Z} (f<α : ∀ β → f β < α)
         → sup (s , f) ≤ α

  -- <sup: strict inequality is witnessed by selecting a child β and
  -- proving α ≤ f β. So α is strictly below the supremum whenever it
  -- is below some child.
  data _<_ : Z → Z → Prop (ℓS ⊔ ℓP) where
    <sup : {s : Sᶻ} {f : Pᶻ s → Z}
         → (β : Pᶻ s) {α : Z}
         → (α≤fi : α ≤ f β)
         → α < sup (s , f)

-- Reflexivity of ≤ is derived by unfolding one layer:
-- show sup(s,f) ≤ sup(s,f) by showing each child f i < sup(s,f),
-- and each f i < sup(s,f) is witnessed by <sup i (≤refl (f i)).
≤refl : ∀ α → α ≤ α
≤refl (sup (_ , f)) = sup≤ (λ i → <sup i (≤refl (f i)))

-- Mutually define transitivity lemmas:
-- ≤≤  : transitivity for ≤
-- ≤<  : pushing < along a ≤ on the right
-- <≤  : pushing ≤ along a < on the left
--
-- These are mutually recursive because the proof of one form typically
-- needs to rewrite into the other form by exposing the sup≤/<sup
-- witnesses.
mutual
  ≤≤ : {α β γ : Z} → β ≤ γ → α ≤ β → α ≤ γ
  ≤≤ β≤γ (sup≤ f<α) = sup≤ λ i → ≤< β≤γ (f<α i)

  ≤< : {α β γ : Z} → β ≤ γ → α < β → α < γ
  ≤< (sup≤ f<α) (<sup i α≤fi) = <≤ (f<α i) α≤fi

  <≤ : {α β γ : Z} → β < γ → α ≤ β → α < γ
  <≤ (<sup i α≤fi) α≤β = <sup i (≤≤ α≤fi α≤β)

-- Every strict inequality implies non-strict inequality.
-- This is a derived lemma and is useful to treat < as giving a ≤-bound.
<→≤ : ∀{α β} → α < β → α ≤ β
<→≤ (<sup i (sup≤ f<β)) = sup≤ (λ j → <sup i (<→≤ (f<β j)))

-- Composition of strict inequalities.
<< : ∀{α β γ} → β < γ → α < β → α < γ
<< (<sup i β≤fi) β<γ = <sup i (<→≤ (≤< β≤fi β<γ))

-- Helper: for any x and any inhabited P s, x is strictly below the
-- one-node tree with shape ιˢ s and all children equal to x.
-- This is used when we need "at least one branch exists" to witness <.
<supᶻ : ∀ {s} x → ∥ P s ∥ → x < sup (ιˢ s , λ _ → x)
<supᶻ x ∣ α ∣ = <sup α (≤refl x)

-- α is strictly below sucᶻ α because sucᶻ α = sup(∨ˢ, _↦α), and we
-- witness < using the left child.
<sucᶻ : ∀ α → α < sucᶻ α
<sucᶻ = λ α → <sup (lift (inj₁ tt)) (≤refl α)

-- Lift the order to the base W-type T via the embedding ιᶻ.
_<ᵀ_ : (W S P) → Z → Prop (ℓS ⊔ ℓP)
t <ᵀ α = ιᶻ t < α

_≤ᵀ_ : (W S P) → Z → Prop (ℓS ⊔ ℓP)
t ≤ᵀ α = ιᶻ t ≤ α

-- Each child is ≤ the supremum. This is often used to weaken bounds.
child≤ : ∀ s f i → f i ≤ sup (s , f)
child≤ s f i = <→≤ (<sup i (≤refl (f i)))

-- Well-foundedness of <. This is essential for defining recursors /
-- inductions on Z and for establishing termination of constructions
-- indexed by Z.
--
-- The proof uses the fact that a < step selects a child, so we can
-- recurse structurally down the tree.
iswf< : WellFounded _<_
iswf< α = acc λ β β<α → p α β (<→≤ β<α)
  where
  p : ∀ α β → β ≤ α → Acc _<_ β
  p (sup (_ , f)) β β≤α = acc q
    where
    q : WfRec _<_ (Acc _<_) β
    q γ γ<β with ≤< β≤α γ<β
    ... | <sup i γ≤fi = p (f i) γ γ≤fi

-- ≤ is a preorder: reflexive and transitive.
isPreorder-≤ : IsPreorder _≤_
isPreorder-≤ = record
  { refl = λ {x} → ≤refl x
  ; trans = λ p q → ≤≤ q p }

-- Package ≤ as a Preorder record; used for diagrams indexed by ≤.
≤p : Preorder (W Sᶻ Pᶻ) _
≤p = _≤_ , isPreorder-≤

-- Alternative characterisations of ≤ via "downward closure" (⊆) and
-- "upward closure" (⊇).
--
-- α ⊆ β means: every γ below α is below β.
-- α ⊇ β means: every γ above α is above β (less commonly used).
_⊆_ : Z → Z → Prop (ℓS ⊔ ℓP)
α ⊆ β = ∀ γ → γ < α → γ < β

_⊇_ : Z → Z → Prop (ℓS ⊔ ℓP)
α ⊇ β = ∀ γ → α < γ → β < γ

-- Show that the "downward closure" notion implies ≤.
-- This gives one direction of quasi-extensionality.
⊆→≤ : ∀ {α β} → α ⊆ β → α ≤ β
⊆→≤ {sup (s , f)} {sup (t , g)} p =
  sup≤ (λ x → p (f x) (<sup x (≤refl (f x))))

-- ≤ implies ⊆. This is the converse direction.
≤→⊆ : ∀ {α β} → α ≤ β → α ⊆ β
≤→⊆ {sup (s , f)} {sup (t , g)} sf≤tg =
  λ γ γ<sf → ≤< sf≤tg γ<sf

-- ≤ implies the corresponding ⊇ direction.
≤→⊇ : ∀ {α β} → α ≤ β → β ⊇ α
≤→⊇ α≤β _ β<γ = <≤ β<γ α≤β

-- Pairwise relations used to state quasi-extensionality as a logical
-- equivalence between (≤ in both directions) and (⊆ in both directions).
_≤≥_ : ∀ (x y : W Sᶻ Pᶻ) → Prop (ℓS ⊔ ℓP)
x ≤≥ y = (x ≤ y) ∧ (y ≤ x)

_⊆⊇_ : ∀ (x y : W Sᶻ Pᶻ) → Prop (ℓS ⊔ ℓP)
x ⊆⊇ y = (x ⊆ y) ∧ (y ⊆ x)

-- Quasi-extensionality: mutual ≤ coincides with mutual ⊆.
-- This is weaker than extensionality of W-trees, but it is enough for
-- the cocontinuity arguments (where we mainly compare ordinals via the
-- induced < relation).
isQuasiExtensionalZ : ∀ {x y} → (x ≤≥ y) ⇔ (x ⊆⊇ y)
isQuasiExtensionalZ =
  (λ (α≤β , β≤α) → ≤→⊆ α≤β , ≤→⊆ β≤α) ,
  λ (α⊆β , β⊆α) → ⊆→≤ α⊆β , ⊆→≤ β⊆α

-- Congruence for ≤: pointwise ≤ on children implies ≤ on sups.
≤cong : ∀ s (μ τ : Pᶻ s → Z) → (r : ∀ i → μ i ≤ τ i)
      → sup (s , μ) ≤ sup (s , τ)
≤cong s μ τ r = sup≤ λ i → <sup i (r i)

-- Strict and non-strict comparisons for join. These are the basic
-- facts used when combining bounds in proofs (especially in ψ-cong and
-- the back direction of cocontinuity).
∨ᶻ-l< : {α β : Z} → α < α ∨ᶻ β
∨ᶻ-l< {α} {β} = <sup (lift (inj₁ tt)) (≤refl α)

∨ᶻ-r< : {α β : Z} → β < α ∨ᶻ β
∨ᶻ-r< {α} {β} = <sup (lift (inj₂ tt)) (≤refl β)

∨ᶻ-l : {α β : Z} → α ≤ α ∨ᶻ β
∨ᶻ-l = child≤ ∨ˢ _ (lift (inj₁ tt))

∨ᶻ-r : {α β : Z} → β ≤ α ∨ᶻ β
∨ᶻ-r = child≤ ∨ˢ _ (lift (inj₂ tt))

-- Commutativity up to ≤: β ∨ᶻ α ≤ α ∨ᶻ β.
-- Again, this is not saying join is a lub; it just gives a convenient
-- inequality needed for "flip" arguments when reindexing bounds.
∨ᶻ-flip : {α β : Z} → β ∨ᶻ α ≤ α ∨ᶻ β
∨ᶻ-flip {α} {β} = sup≤ g
  where
  g : (i : Pᶻ ∨ˢ) → _ < (α ∨ᶻ β)
  g (lift (inj₁ tt)) = <sup (lift (inj₂ tt)) (≤refl β)
  g (lift (inj₂ tt)) = <sup (lift (inj₁ tt)) (≤refl α)
