Hi Thorsten,

I've had a look at those, thanks for sending them over, the idea looks really interesting, though I imagine there's a lot of challenges to making higher coinductive types work practically. Presumably the path constructors are still inductive?

A bit of an update: I have been working in this repository: 

  -- The carrier of the colimit (Sigma type)
  Colim₀ : Set (ℓI ⊔ ℓB)
  Colim₀ = Σ[ i ∈ ⟨ I ⟩ ] ⟨ P̂ i ⟩

  data _≈ˡ_ : Colim₀ → Colim₀ → Prop (ℓ≤ ⊔ ℓI ⊔ ℓB ⊔ ℓB') where
    ≈lstage : ∀ i → {x x' : ⟨ P̂ i ⟩} → P̂ i [ x ≈ x' ] → (i , x) ≈ˡ (i , x')
    ≈lstep  : ∀ {i j} (p : i ≤ j) (x : ⟨ P̂ i ⟩) → (i , x) ≈ˡ (j , Pf p x)
    ≈lsym   : ∀ {s t} → s ≈ˡ t → t ≈ˡ s
    ≈ltrans : ∀ {s t u} → s ≈ˡ t → t ≈ˡ u → s ≈ˡ u

where P Is the diagram over a setoid I

I've proven that this is in fact a limiting cocone as expected so I'm happy with this part.

I'm on cocontinuity and I've done the easy direction and proven congruence of phi:

    ϕ₀ : ⟨ Colim (F̃ ∘ D) ⟩ → ⟨ F.F-ob (Colim D) ⟩
    ϕ₀ (i , (l , _)) = l , (λ ())
    ϕ₀ (i , (n , f)) = n , (λ b → i , f b)

    ψ₀ : ⟨ F.F-ob (Colim D) ⟩ → ⟨ Colim (F̃ ∘ D) ⟩
    ψ₀ (l , _) = sup (l , (λ ())) , l , (λ ())
    ψ₀ (n , f) = sup (n , g) , (n , h)
      where
      g : B → ⟨ MobileSetoid ⟩
      g b = f b .proj₁
      h : B → ⟨ D.D-ob (node g) ⟩
      h b = sz (g b) gb<ng
        where
        gb<ng : g b < node g
        gb<ng = <sup b (≤refl (g b))

Note that `node g` is a pattern for `sup (n , g)` where {n,l} are atoms for the node/leaf shapes.

Backward (psi) congruence is a bit trickier, since you have to show that the equations for each branch position can propagate to the whole mobile, and this creates some unification nightmares. Maybe I should have stuck with cubical!

    ψ-cong : ∀ {x y} → F.F-ob (Colim D) [ x ≈ y ]
           → Colim (F̃ ∘ D) [ ψ₀ x ≈ ψ₀ y ]
    -- easy cases omitted
    -- snd≈ tells us that we have equality on each branch.
    ψ-cong {n , f1} {n , f2} (mk≈ꟳ ≡.refl snd≈) =
      begin
      ψ₀ (n , f1)
        ≈⟨ C.refl ⟩
      sup (n , g1) , (n , h1)
        ≈⟨ {!!} ⟩
      sup (n , g2) , (n , h2)
        ≈⟨ C.refl ⟩
      ψ₀ (n , f2) ∎
      where
      module C = Setoid (Colim (F̃ ∘ D))
      module M = Setoid MobileSetoid
      open ≈.≈syntax {S = Colim (F̃ ∘ D)}
      g1 : B → ⟨ MobileSetoid ⟩
      g1 b = f1 b .proj₁
      h1 : B → ⟨ D.D-ob (sup (n , g1)) ⟩
      h1 b = sz (g1 b) (<sup b (≤refl (g1 b)))
      g2 : B → ⟨ MobileSetoid ⟩
      g2 b = f2 b .proj₁
      h2 : B → ⟨ D.D-ob (sup (n , g2)) ⟩
      h2 b = sz (g2 b) (<sup b (≤refl (g2 b)))

We can't pattern match on even a single `snd≈ b` because we haven't unified g1 and g2, and I'm not sure how to get past it. I imagine showing both directions are inverses will run into something similar. It's possible that redefining the colimit definition to explicitly use an identity proof. Replacing ≈lstage with this should avoid the unification issue, but I haven't had a chance to try it yet.

    ≈lstage : ∀ {i j} (i I.≈ j) → {x x' : ⟨ P̂ i ⟩} → P̂ i [ x ≈ x' ] → P̂ j [ x ≈ x' ] → (i , x) ≈ˡ (j , x')

but we can't create a path across i even with this without defining ≈ˡ (limit paths) and  in the HoTT way as paths, so that we would be defining higher paths instead of setoids, which changes the entire construction. The homogenity of 

  data _≈ᵗ_ : BTree → BTree → Prop l0 where
    ≈leaf : leaf ≈ᵗ leaf
    ≈node : ∀ {f g} → (c : ∀ b → f b ≈ᵗ g b)
          → node f ≈ᵗ node g
    ≈perm : ∀ {f} → (π : ≈.Iso Bˢ Bˢ)
          → node f ≈ᵗ node λ b → f (≈.Iso.⟦_⟧ π b)
    ≈trans : ∀ {s t u} → s ≈ᵗ t → t ≈ᵗ u → s ≈ᵗ u

I do want to go through what I've done so far with you at some point just to check I haven't made an obvious mistake, but I think I'm mostly on track.
